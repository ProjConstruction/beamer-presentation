\documentclass[9pt]{beamer}

\mode<presentation> {

\usetheme{Madrid}

\usepackage{amsfonts}
\usepackage{mathrsfs}
\usepackage{amscd}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{latexsym}
\usepackage{lscape}
\usepackage{xypic}
\usepackage{comment}
\usepackage{amscd}
\usepackage{wasysym}  
\usepackage{tikz}
\usetikzlibrary{cd, external, decorations.pathmorphing, fit, backgrounds, tikzmark, calc, shapes.misc, positioning}

\usepackage{appendix}
\usepackage{geometry}
\usepackage[nice]{nicefrac}
\usepackage{dsfont, stmaryrd}
\usepackage{array}

\usepackage{listings}
\usepackage{lstautogobble}
\usepackage{lstlinebgrd}

\usepackage{xcolor}
\definecolor{keywordcolor}{rgb}{0.7, 0.1, 0.1}   % red
\definecolor{tacticcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{commentcolor}{rgb}{0.4, 0.4, 0.4}   % grey
\definecolor{symbolcolor}{rgb}{0.0, 0.1, 0.6}    % blue
\definecolor{sortcolor}{rgb}{0.1, 0.5, 0.1}      % green
\definecolor{attributecolor}{rgb}{0.7, 0.1, 0.1} % red
\def\lstlanguagefiles{lstlean.tex}
% set default language
\lstset{
  language=lean, 
  basicstyle=\ttfamily,
  autogobble=true,
  escapeinside={(*@}{@*)},
  captionpos=t,
  aboveskip=0.5em,
  belowskip=0.5em}

\usepackage{mymacros}
\usepackage{soul}
\usepackage[most]{tcolorbox}
\tcbuselibrary{theorems, skins, breakable}
% \usepackage{MnSymbol}
\usepackage{upgreek}

\newcommand{\nc}{\newcommand}
\newtheorem{prop}[theorem]{Proposition}

\newtheorem{theo}[theorem]{Theorem}

\newtheorem{coro}[theorem]{Corollary}

\newtheorem{defi}[theorem]{Definition}


\newtheorem{exam}[theorem]{Example}


\nc{\Spec}{{{\mathrm{Spec}}}}
\nc{\Hom}{{{\mathrm{Hom}}}}
\nc{\homm}{{\underline{\mathrm{Hom}}}}
\nc{\frakg}{{\mathfrak{g}}}
\nc{\fm}{{\mathfrak{m}}}
\nc{\fa}{{\mathfrak{a}}}
\nc{\calA}{{\mathcal A}}
\nc{\calB}{{\mathcal B}}
\nc{\calC}{{\mathcal C}}
\nc{\calD}{{\mathcal D}}
\nc{\calE}{{\mathcal E}}
\nc{\calF}{{\mathcal F}}
\nc{\calG}{{\mathcal G}}
\nc{\calH}{{\mathcal H}}
\nc{\calI}{{\mathcal I}}
\nc{\calJ}{{\mathcal J}}
\nc{\calK}{{\mathcal K}}
\nc{\calL}{{\mathcal L}}
\nc{\calM}{{\mathcal M}}
\nc{\calN}{{\mathcal N}}
\nc{\calO}{{\mathcal O}}
\nc{\calP}{{\mathcal P}} 
\nc{\calQ}{{\mathcal Q}} 
\nc{\Q}{{\mathbb Q}}
\nc{\R}{{\mathbb R}}
\nc{\calS}{{\mathcal S}}
\nc{\calT}{{\mathcal T}}
\nc{\calU}{{\mathcal U}}
\nc{\calV}{{\mathcal V}}
\nc{\calW}{{\mathcal W}}
\nc{\calX}{{\mathcal X}}
\nc{\calY}{{\mathcal Y}}

\nc{\bbZ}{{\mathbb{Z}}}
\nc{\zp}{{\mathbb{Z}_p}}

\nc{\bbN}{{\mathbb{N}}}

\nc{\fp}{{\mathfrak{p}}}

\nc{\fq}{{\mathfrak{q}}}


\nc{\proj}{{\mathrm{Proj}}}


\nc{\N}{{\mathbb{N}}}

\nc{\bbP}{{\mathbb{P}}}
\nc{\Z}{{\mathbb{Z}}}
\nc{\C}{{\mathbb{C}}}
\nc{\Gm}{{\mathbb{G}_m}}
\nc{\Aa}{{\mathbb{A}}}


%\setbeamertemplate{footline} % To remove the footer line in all slides uncomment this line
%\setbeamertemplate{footline}[page number] % To replace the footer line in all slides with a simple slide count uncomment this line

%\setbeamertemplate{navigation symbols}{} % To remove the navigation symbols from the bottom of all slides uncomment this line
}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{graphicx} % Allows including images
\usepackage{booktabs} % Allows the use of \toprule, \midrule and \bottomrule in tables

%----------------------------------------------------------------------------------------
%	TITLE PAGE
%----------------------------------------------------------------------------------------

\title[ Proj and Formalisation]{$~~~~$ Formalising the Multigraded Proj Construction in Lean 4. $~~~~$\\ }

\author{Arnaud Mayeux and Jujian Zhang } 
\institute[] 
{
\\ 
\medskip
\textit{} 
}
\date{Formalisation of mathematics with interactive theorem provers  \\ Thursday 19 June 2025 } 

\begin{document}

\begin{frame}
\titlepage % Print the title page as the first slide


\end{frame}




\begin{frame}{Introduction}
Inspired by projective geometry, Grothendieck defined the Proj scheme of a $\bbN$-graded ring $A$. This is a well-known construction that every mathematician in scheme theory know and that is explained in most books about algebraic geometry. 


\[
\includegraphics[scale=0.24]{p1.png} \]\[  \mathrm{Proj} (\mathbb{R}[X,Y])
\]
\[deg(X)=deg(Y)=1\]
\end{frame}
\begin{frame}


\includegraphics[scale=0.6]{EGA1961.png}

\includegraphics[scale=0.6]{captureEGA1961.png}

\end{frame}

\begin{frame}
In Hartshorne: 

\[\includegraphics[scale=0.4]{captureHartshorne.png}\]

\[\includegraphics[scale=0.4]{captureHartshorne2.png}\]
\end{frame}
\begin{frame}
Similar treatments appear in:

$~~$

-A. Ducros: "Introduction à la théorie des schémas" (Msc course 2021 Paris)

$~~$

-R. Vakil : "THE RISING SEA Foundations of Algebraic Geometry" (Msc book course 2024 Stanford)

$~~$

-Görtz-Wedhorn: "Algebraic Geometry I: Schemes " (Msc book course 2010)

$~~$

-Eisenbud-Harris: "The geometry of schemes" (Msc book course 2000)


$~~$

-Qing Liu: "Algebraic Geometry and Arithmetic Curves" (Msc book course 2002)

$~~$

-Stacks Project 

$~~$


-...



Beyond the definition of Proj, all these treatments also study quasi-coherent sheaves and twisting sheaves on Proj and use Proj to define "blowups."  

This construction was formalised by J. Zhang in Lean. 

So it seems it is the end of this Proj story. 

But...
\end{frame}
 \begin{frame}
Question: Why Grothendieck assume that $A$ is $\bbN$-graded instead of graded by a general commutative monoid or group ? 

$~$

Answer: No reason from the point of view of Grothendieck scheme theory, in fact Brenner-Schröer defined the Proj of a ring graded by an arbitrary finitely generated abelian group $M$.

$~~$
\[
\includegraphics[scale=0.5]{BS.png}\]
\[
\includegraphics[scale=0.6]{captureBS.png}
\]
None of the above references mention Brenner-Schröer work. 

Goal of this talk: discuss Brenner-Schröer construction, new results and formalization. 
\end{frame}



\begin{frame}{References for this talk }

$~~$

H. Brenner and S. Schr\"oer, Ample families, multihomogeneous spectra, and algebraization of formal schemes, Pacific J. Math. {\bf 208} (2003), no.~2, 209--230.

$~~$

A. Mayeux and S. Riche, On multi-graded Proj schemes, to appear in P.R.I.M.S., Kyoto University

$~~$


A. Mayeux and J. Zhang, Multi-graded Proj construction in Lean4, https://github.com/ProjConstruction/Proj 

$~~$

J. Zhang, Formalising the Proj construction in Lean, in {\it 14th International Conference on Interactive Theorem Proving}, Art. No. 35, LIPIcs. Leibniz Int. Proc. Inform., 268.
\end{frame}


\begin{frame}{Why formalizing? }

- Being sure that there is no error (rigor).

$~~$

$~~$

- Provide data for future AI-mathematics.




\end{frame}


\begin{frame}{Graded localization}
If a given commutative ring $A$ is $M$-graded for some abelian group $M$, we will say that a multiplicative subset is homogeneous if it consists of homogeneous elements. 

If $A$ is a commutative $M$-graded ring and $S \subset A$ is a homogeneous multiplicative subset, the localization $A_S$ of $A$ with respect to $S$ is canonically $M$-graded, explicitly, for $m \in M$ we have
\[
( A_S)_m =  \left\{ \frac{a}{s} : \exists m', m'' \in M \text{ such that }  a \in A_{m'}, \, s \in (S \cap A_{m''}) \text{ and
$m'-m'' =m$ }\right\}.
%\subset A_S.
\]
Given a graded $A$-module $Q$, one can also consider the associated localization $Q_S$, which has a natural structure of a graded $A_S$-module.

Given a homogeneous multiplicative subset $S \subset A$, we will denote by $\underline{S}$ the homogeneous multiplicative subset consisting of homogeneous divisors of elements in $S$. Note that we have a canonical isomorphism of graded rings
\begin{equation}
\label{eqn:isom-localizations}
 A_{ \underline{S}} \cong A_{S}.
\end{equation}
If $Q$ is a graded $A$-module we also have a canonical identification of graded abelian groups 
\begin{equation}
\label{eqn:isom-localizations-modules}
Q_{\underline{S}} \cong Q_S
\end{equation}
compatible with the actions of $A_{ \underline{S}} = A_{S}$.

\end{frame}


\begin{frame}


Consider an abelian group $M$, and a commutative $M$-graded ring $A$. 

 \begin{block}{Definition}
 Let $S$ be a homogeneous subset of $A$. We denote by $\deg(S)$ the subset of $M$ defined as 
\[\deg(S):= \{ m \in M : \exists s \in S , s  \in A_m \}. \]
 \end{block} 
Note that $\deg(\{0\})=M$.
More generally, if $S$ is a homogeneous multiplicative subset of $A$, then $\deg(S)$ is a submonoid of $M$, also denoted $M[S\rangle$.

\begin{block}{Definition}
Let $S$ be a homogeneous multiplicative subset of $A$. 
 We put $M[S]=M[S \rangle^{\mathrm{gp}}= M[S \rangle- M[S \rangle$, the subgroup of $M$ generated by $\deg(S)$.

\end{block}


\begin{block}{Definition (Relevant)}
\begin{enumerate} \item 
 A homogeneous multiplicative subset $S$ of $A$ is called \emph{$M$-relevant} (or just \emph{relevant} if $M$ is clear from the context) if for any $m$ in $M$ there exists $n \in \bbZ_{> 0}$ such that $nm$ belongs to $M[\underline{S}]$, i.e. if $M/(M[\underline{S}])$ is a torsion abelian group.

 \item
 A family $\{a_i : i \in I\}$ of homogeneous elements in $A$ is called $M$-relevant if the multiplicative subset generated by the $a_i$'s is relevant.
 \item
 A homogeneous element $a \in A$ is called $M$-relevant if the family $\{a\}$ is $M$-relevant.
\end{enumerate}\end{block}

\end{frame}


\begin{frame}


Let $M$ be an abelian group, and let $A$ be a commutative $M$-graded ring.

Let $S$ be a homogeneous multiplicative subset of $A$. \begin{block}{Definition}
\begin{enumerate}
\item
The degree-$0$ part $(A_S)_0$ of the localization $A_{S}$ is denoted $A_{(S)}$ and is called the \emph{potion} of $A$ with respect to $S$. 
\item
If $Q$ is a graded $A$-module, we will also denote by $Q_{(S)}$ the degree-$0$ part $(Q_S)_0$ of $Q_S$; it admits a canonical structure of an $A_{(S)}$-module.
\end{enumerate}
\end{block}


We have canonical identifications
$A_{(\underline{S})} \cong A_{(S)}$ and $Q_{(\underline{S})} \cong Q_{(S)}$.
If  $\{a_i : i \in I \}$ is a family of homogeneous elements of $A$, we will denote by
$A_{(\{a_i : i \in I \})}$
the potion associated with the multiplicative subset of $A$ generated by $\{a_i : i \in I \}$; in case $\#I=1$ we will write $A_{(a)}$ for $A_{(\{a\})}$.

If $S$ and $T$ are multiplicative subsets of $A$, we will denote by $ST$ the multiplicative subset of $A$ generated by $S \cup T$, i.e. $ST = \{st : s \in S, \, t \in T \}$. Of course, $ST$ is homogeneous if $S$ and $T$ are.\end{frame}\begin{frame}
The following is the key result that makes the Proj construction work.

\begin{block}{Proposition (Magic of potions)}
\label{prop:magical} 
Let $S$ and $T$ be homogeneous multiplicative subsets of $A$. 
\begin{enumerate}
\item 
\label{it:magic-1}
We have a canonical homomorphism of potion rings 

$A_{(S )} \to  A_{(ST )}$.
%\]
\item 
\label{it:magic-2}
Assume that $S$ is relevant. Fix a subset $T' \subset T$ which generates $T$ as a submonoid of $(A,\times)$ and, for any $t $ in $T'$, fix $n_t \in \mathbb{N}_{>0}$ and $s_t, s_t' \in \underline{S}$ such that $\deg(t^{n_t}) = \deg(s_t)-\deg(s_t')$.
%$t^{n_t} \smile s_t$. 
Then $\frac{t^{n_t} s_t'} { s_t}$ belongs to $A_{(\underline{S} )}=A_{(S)}$. 
 Moreover we have a canonical isomorphism of $A_{(S )}$-algebras between $ A_{(ST )}$ and the localization of $A_{(S )}$ with respect to the multiplicative subset of $A_{(S)}$ generated by $\{\frac{t^{n_t} s_t'} { s_t} : t \in T' \}$.
\item 
\label{it:magic-3}
Assume that $S$ is relevant and that $T$ is finitely generated as submonoid of $(A,\times)$. The morphism of schemes 
$
\mathrm{Spec} (A_{(ST )}) \to \mathrm{Spec} (A_{(S)})
$
induced by the ring homomorphism in~\eqref{it:magic-1} is an open immersion of schemes.
\item 
\label{it:magic-4}
Let $f_1, \ldots, f_n \in A$ be nonzero relevant homogeneous elements of the same degree.
Then we have a canonical open immersion
\[
\Spec(A_{ (f_1 + \cdots + f_n) }) \to \Spec (A_{(f_1)}) \cup \cdots \cup \Spec (A_{(f_n)})
\]
where the right-hand side is defined as the glueing of the affine schemes $\Spec (A_{(f_i)})$ along the open subschemes $\Spec (A_{(f_i \cdot f_j)}) \subset \Spec (A_{(f_i)})$ (see~\eqref{it:magic-3}).

\end{enumerate}
\end{block}
\end{frame}

\begin{frame}


From now on we assume that $M$ is a \emph{finitely generated} abelian group, and fix a commutative $M$-graded ring $A$.

We will denote by $\mathcal{F}_A$ the set of all relevant homogeneous multiplicative subsets of $A$ which are finitely generated as submonoids of $(A,\times)$.

\begin{block}{Construction (Proj as glueing potions)}

Let
$\mathcal{F} \subset \mathcal{F}_A$ be a subset.
 For each $S \in \mathcal{F}$, let $D_{\dagger}(S)$ be the spectrum of the potion $A_{(S)}$. 
 If $S,T \in \mathcal{F}$, the affine scheme $D_{\dagger}(ST)$ identifies canonically with an open subscheme of $D_{\dagger}(S)$. For each $S,T \in \mathcal{F}$, we have equalities
 \[
 D_{\dagger}({S S}) = D_{\dagger}(S) \quad \text{and} \quad D_{\dagger}({ST})=D_{\dagger}({TS}).
 \]
 Moreover, for each triple $S,T,U \in \mathcal{F}$, we have
 \[
 D_{\dagger}({ST} )\cap D_{\dagger}({SU}) = D_{\dagger}({TS}) \cap D_{\dagger}({TU}).
 \]

Now, by glueing, from these data we obtain a scheme $\mathrm{Proj}^M_{\mathcal{F} } (A)$ and, for each $S \in \mathcal{F}$, an open immersion $\varphi_S : D_{\dagger}(S) \to \mathrm{Proj}^M_{\mathcal{F}} (A)$, such that
\[
\mathrm{Proj}^M_{\mathcal{F} } (A) = \bigcup_{S \in \mathcal{F} } \varphi_S( D_{\dagger}(S)).
\]

In practice, we will often identify $D_{\dagger}(S) $ and $\varphi_S (D_{\dagger}(S))$. 


In the case when $\mathcal{F} = \mathcal{F}_A$,
 the scheme $\mathrm{Proj}^M_{\mathcal{F}_A} (A)$ will be denoted $\mathrm{Proj}^M(A)$, or just $\mathrm{Proj}( A)$ when $M$ is clear from the context.
 \end{block}

 \end{frame}




\begin{frame}

\begin{block}{Proposition} 
The scheme $\mathrm{Proj}^M(A)$ is quasi-separated.
\end{block}

\begin{block}{Proposition (Functoriality of Proj)} 
Let $\Psi:A \to B $ be a homomorphism of $M$-graded rings. 
For any $\mathcal{F} \subset \mathcal{F}_A$ 
we have a canonical morphism of schemes $\mathrm{Proj}^M_{\Psi (\mathcal{F})} (B) \to \mathrm{Proj}^M_{\mathcal{F} } (A)$. Moreover, for any $S \in \calF$ we have
\begin{equation}
\mathrm{Proj}^M_{\Psi(\calF)}(B) \times_{\mathrm{Proj}_{\calF}^M(A)} D_\dag(S) = D_\dag(\Psi(S));
\end{equation}
in particular, the morphism is affine.
\end{block}

\begin{block}{Proposition}
Assume that $\Psi : A \to B$ is surjective. Then we have $\mathrm{Proj}^M_{\Psi (\mathcal{F}_A)} (B) = \mathrm{Proj}^M (B)$, and the canonical morphism
 $\mathrm{Proj}^M(B) \to \mathrm{Proj}^M(A)$
is a closed immersion.
\end{block}

 \end{frame}


\begin{frame}

\begin{block}{Proposition}
 Let $M$ and $M'$ be two finitely generated abelian groups. Let $R$ be a commutative ring and let $A$ (resp.~$A'$) be a commutative $M$-graded (resp.~$M'$-graded) $R$-algebra. 
 Then for the natural $(M \times M')$-grading on $A \otimes_R A'$, we have a canonical isomorphism
 \[
 \mathrm{Proj} ^{M \times M'} (A \otimes_R A') \cong \mathrm{Proj} ^M (A) \times_{\Spec(R)} \mathrm{Proj} ^{M'} (A'). 
 \]
\end{block}

\end{frame}



\begin{frame}{Quasi-coherent sheaves}

Let $Q$ be an $M$-graded $A$-module. For any homogeneous multiplicative subset $S \subset A$, we have considered the $A_{(S)}$-module $Q_{(S)}$. The following fact is immediate by glueing of quasi-coherent sheaves.


\begin{block}{Definition}
There exists 
a unique quasi-coherent $\mathcal{O}_{\mathrm{Proj}^M(A)}$-module $\widetilde{Q}$ such that
$\Gamma \bigl( D_\dag(S)  , \widetilde{Q} \bigr) = Q_{(S)}$
for every $S \in \calF_A$.
\end{block}

An $M$-graded $A$-module $Q$ will be called \emph{negligible} if $\widetilde{Q}=0$.


\end{frame}


\begin{frame}{Twisting sheaves}

We now define the versions in our setting of the twisting sheaves. 
If $Q$ is a graded $A$-module and $\alpha \in M$, we will denote by $Q(\alpha)$ the $M$-graded $A$-module which coincides with $M$ as an $A$-module, but with the $M$-grading defined by $(Q(\alpha))_\beta = Q_{\alpha+\beta}$ for $\beta \in M$.


\begin{block}{Definition (Twisting sheaves)}
Let $\alpha \in M$.
\begin{enumerate}
\item
The quasi-coherent sheaf $\widetilde{A(\alpha)}$ on $\mathrm{Proj}^M(A)$ is 
denoted $\mathcal{O}_{\mathrm{Proj}^M(A)} (\alpha)$.
\item
If $\calQ$ is a sheaf of $\calO_{\mathrm{Proj}^M(A)}$-modules, we set $\calQ (\alpha) = \calO_{\mathrm{Proj}^M(A)} (\alpha ) \otimes_{\calO_{\mathrm{Proj}^M(A)}} \calQ$.
\end{enumerate}
\end{block}


\begin{block}{Proposition}
Assume that $A$ is a noetherian ring.
\begin{enumerate}
\item
For any $\alpha \in M$, the quasi-coherent sheaf $\mathcal{O}_{\mathrm{Proj}^M(A)} (\alpha)$ is coherent.
\item
If $Q$ is a finitely generated $M$-graded $A$-module, then $\widetilde{Q}$ is coherent.
\end{enumerate}
\end{block}


\end{frame}

\begin{frame}

A family $S \in \calF_A$ will be called \emph{maximally relevant} if $M[\underline{S}]=M$.   We will denote by $\calF_A^{\mathrm{m}} \subset \calF_A$ the subset consisting of maximally relevant families. In this subsection we will explore various consequences of the following condition (which may or may not hold, depending on $A$):
\begin{equation}
\label{eqn:cover-max}
\mathrm{Proj}^M(A) = \bigcup_{S \in \calF_A^{\mathrm{m}}} D_\dag(S).
\end{equation}


\begin{block}{Proposition}
Assume that~\eqref{eqn:cover-max} is satisfied. Then for any $ \alpha \in M$, the quasi-coherent $\calO_{\mathrm{Proj}^M(A)}$-module $\calO_{\mathrm{Proj}^M(A)} (\alpha)$ is an invertible sheaf.
\end{block}

\begin{block}{Proposition}
Assume that~\eqref{eqn:cover-max} is satisfied, and moreover that $\mathrm{Proj}^M(A)$ is quasi-compact. Then the functor
\[
\mathsf{L} : \mathrm{Mod}^M(A) / \mathrm{Mod}^M(A)_{\mathrm{neg}} \to \mathrm{QCoh}(\mathrm{Proj}^M(A))
\]
is an equivalence of categories.
\end{block}
\end{frame}



\begin{frame}{Example: Flag variety as Proj}
 Let $k$ be an algebraically closed field and let $G$ be
a connected reductive group scheme over $k.$ Let $T$ be a maximal split torus
and $B$ be a Borel subgroup such that $B = T N$ where $N$ is the unipotent
radical. Then $G/N$ is quasi-affine and the ring $A := \Gamma (G/N, \mathcal{O}_{G/N} )$ is canonically $X^*(T)$-graded. We have a schematically dominant open immersion
$G/N \to \mathrm{Spec}(A)$. 

\begin{block}{Proposition}
The flag variety $G/B$ identifies with $\mathrm{Proj}^{X^*(T)} (A)$.
\end{block}
Consider a finite-dimensional $G$-module $\widetilde{V}$ and a $B$-stable subspace $V \subset \widetilde{V}$. 
We can then consider the induced scheme
\[
 G \times^{B} V,
\]
i.e.~the quotient of the product $G \times V$ by the (free) action of $B$ defined by $b \cdot (g,x) = (gb^{-1}, b \cdot x)$.  It is a vector bundle over $G/B$.

There is a canonical way to see such schemes as Proj schemes.

An interesting case is when $\widetilde{V}$ is the Lie algebra $\mathfrak{g}$ of $G$ and $V$ is the Lie algebra $\mathfrak{n}$ of the unipotent radical of $B$. In this case, $G \times^{B} V$ is the so-called \emph{Springer resolution}

\end{frame}


\begin{frame}{Conclusion}


\begin{tabular}{|l|c|r|}
  \hline
  \textbf{Property of the Proj construction} & Grothendieck setting  & Brenner-Schröer setting \\
  \hline
  Grading & $\bbN $ & \text{any f.g. ab. gp $M$} \\
  \hline
  Definition via prime ideals works & Yes & No\\
   \hline
  Definition via prime ideals required & No & No\\
  \hline
  Definition via glueing works & Yes & Yes\\
  \hline 
  Glueing steps required & Yes & Yes \\ 
  \hline
  Twsiting sheaves available & Yes & Yes \\ 
  \hline
 Compatible with tensor product & No & Yes \\ 
  \hline
  Separated & Yes & No, but quasi-separated \\
  \hline 
  Compatible with blowups & Yes & Yes \\
  \hline 
  Allows to describe G/B canonically  & No & Yes \\
  \hline 
  Qcoh on Proj via graded modules   & Yes & Yes \\
  \hline 
  Verified in Lean    & Yes & Yes \\
  \hline 
\end{tabular}

$~~$

$~~$

Moreover: 

The level of technicality in the Grothendieck setting is almost the same as that in the Brenner–Schröer setting.

\end{frame}



\begin{frame}{Lean4 Formalization}

In our joint work on the formalization we formalized: 
\begin{enumerate}
\item Localization of graded rings and potions

\item Magic of potions 

\item The definition of Proj via glueing 

\item Twisting modules
\end{enumerate}
We plan to formalize:

\begin{enumerate} \item Existence of blowups via Proj and dilatations 
\item Quasi-coherent sheaves on Proj
\end{enumerate}



We use much of the material on the formalization of scheme theory available in mathlib (Buzzard et al.).
Previously, Jujian Zhang formalized the $\mathbb{N}$-graded $\mathrm{Proj}$ construction, and we use a lot of graded algebras from this work. 



 Though the multi-graded Proj construction generalises the $\mathbb{N}$-graded one, the formalisation remains indepdenent because we used the gluing approach instead of the graded ideals approach. 

 It would also be very interesting to formalise some aspects of group schemes, in particular to formalize the description of the flag variety via Proj schemes.

\end{frame}




\begin{frame}{Various remarks}
\begin{itemize}

  
  \item In the long run, we expect formalised mathematics to become the new standard. This will be the starting point for non-hallucinating, AI-powered advanced mathematical research.
  
  \item It would be very exciting to see advance in AI-automated formalisation.
  
  \item It would be very interesting to see a more PDF\LaTeX-friendly interface  in Lean (cf. the power of good notations in mathematics). In practice the Lean code sometimes becomes hard to read in comparison with a math formula (as in \LaTeX codes).
     \LaTeX $\leadsto$ PDF  ,      Lean4 $\not \leadsto$ PDF 
  
  \item As of Spring 2025, Copilot (Lean AI) remained insufficiently effective for assisting with the formalisation of algebraic geometry. Copilot was not able to prove that 0x1=0 in a certain non-trivial graded ring (the underlying set was already formally defined and we were formalising that it is a ring). However Copilot was able to fill by himself repetitive arguments. With more and more formalised works and current AI-research, Copilot will improve and be able to prove routine like 0x1=0 soon. 
  
  \item As of Spring 2025, without J. Zhang's collaboration, it would have been impossible for me (I had no experience with Lean before) to reach the formalisation of the multigraded Proj construction in such a short time. However, as a joint project, we encountered no significant difficulties and completed the formalisation of Proj before the paper was accepted.
  
  \item Future human mathematicians will learn Lean like previous ones used to learn \LaTeX. 
\end{itemize}


\end{frame}


\section{Implementation in Lean4}
\begin{frame}[fragile]
\frametitle{Graded objects in Lean4}

\begin{lstlisting}[mathescape=true, extendedchars=true]
variable {A M ιA ιM σA σM : Type*} 
variable [Ring A] [AddCommGroup M] [Module A M]
variable ($\mathcal{A}$ : ιA → σA) ($\mathcal{M}$ : ιM → σM)
variable [DecidableEq ιA] [AddMonoid ιA] [DecidableEq ιM]  [VAdd ιA ιM]
variable [SetLike σA A] [SetLike σM M]
variable [AddSubgroupClass σA A] [AddSubgroupClass σM M] 
variable [GradedRing $\mathcal{A}$] 
variable [DirectSum.Decomposition $\mathcal{M}$] [SetLike.GradedSMul $\mathcal{A}$ $\mathcal{M}$]
\end{lstlisting}
\begin{itemize}
  \item \lstinline|[SetLike σA A]| and \lstinline|[AddSubgroupClass σA A]| together assert that the terms of \lstinline|σA| are subgroups of $A$.
%   \item<2> \lstinline[mathescape=true]|[GradedRing $\mathcal{A}$]| is an abbreviation for \lstinline[mathescape=true]|[DirectSum.Decomposition $\mathcal{A}$]| and 
% \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{A}$]| where \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{\McA}$]| is an abbreviation for 
% \lstinline[mathescape=true]|[SetLike.GradedOne $\mcA$]| asserting that $1$ has grade zero and \lstinline[mathescape=true]|[SetLike.GradedMul $\mcA$]| asserting that $\mcA_i\mcA_j \subseteq \mcA_{i+j}$.
%   \item<3> \lstinline[mathescape=true]|[SetLike.GradedSMul $\mcA$ $\mcM$]| asserts that $\mcA_i \cdot \mcM_j \subseteq \mcM_{i+j}$ where $i + j$ is provided by \lstinline|[VAdd ιA ιM]|. 
%   \item<4> The general setup here is versatile: by allowing \lstinline|ιA| and \lstinline|ιM| to be different types, we can have graded rings and modules that are not graded by the same monoid --- for example the ring is graded by $\NN$ and the module by $\ZZ$.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Graded objects in Lean4}

\begin{lstlisting}[mathescape=true, extendedchars=true]
variable {A M ιA ιM σA σM : Type*} 
variable [Ring A] [AddCommGroup M] [Module A M]
variable ($\mathcal{A}$ : ιA → σA) ($\mathcal{M}$ : ιM → σM)
variable [DecidableEq ιA] [AddMonoid ιA] [DecidableEq ιM]  [VAdd ιA ιM]
variable [SetLike σA A] [SetLike σM M]
variable [AddSubgroupClass σA A] [AddSubgroupClass σM M] 
variable [GradedRing $\mathcal{A}$] 
variable [DirectSum.Decomposition $\mathcal{M}$] [SetLike.GradedSMul $\mathcal{A}$ $\mathcal{M}$]
\end{lstlisting}
\begin{itemize}
  % \item<1> \lstinline|[SetLike σA A]| and \lstinline|[AddSubgroupClass σA A]| together assert that the terms of \lstinline|σA| are subgroups of $A$.
  \item\lstinline[mathescape=true]|[GradedRing $\mathcal{A}$]| is an abbreviation for \lstinline[mathescape=true]|[DirectSum.Decomposition $\mathcal{A}$]| and 
\lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{A}$]| where \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{\McA}$]| is an abbreviation for 
\lstinline[mathescape=true]|[SetLike.GradedOne $\mcA$]| asserting that $1$ has grade zero and \lstinline[mathescape=true]|[SetLike.GradedMul $\mcA$]| asserting that $\mcA_i\mcA_j \subseteq \mcA_{i+j}$.
  % \item<3> \lstinline[mathescape=true]|[SetLike.GradedSMul $\mcA$ $\mcM$]| asserts that $\mcA_i \cdot \mcM_j \subseteq \mcM_{i+j}$ where $i + j$ is provided by \lstinline|[VAdd ιA ιM]|. 
  % \item<4> The general setup here is versatile: by allowing \lstinline|ιA| and \lstinline|ιM| to be different types, we can have graded rings and modules that are not graded by the same monoid --- for example the ring is graded by $\NN$ and the module by $\ZZ$.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Graded objects in Lean4}

\begin{lstlisting}[mathescape=true, extendedchars=true]
variable {A M ιA ιM σA σM : Type*} 
variable [Ring A] [AddCommGroup M] [Module A M]
variable ($\mathcal{A}$ : ιA → σA) ($\mathcal{M}$ : ιM → σM)
variable [DecidableEq ιA] [AddMonoid ιA] [DecidableEq ιM]  [VAdd ιA ιM]
variable [SetLike σA A] [SetLike σM M]
variable [AddSubgroupClass σA A] [AddSubgroupClass σM M] 
variable [GradedRing $\mathcal{A}$] 
variable [DirectSum.Decomposition $\mathcal{M}$] [SetLike.GradedSMul $\mathcal{A}$ $\mathcal{M}$]
\end{lstlisting}
\begin{itemize}
%   \item<1> \lstinline|[SetLike σA A]| and \lstinline|[AddSubgroupClass σA A]| together assert that the terms of \lstinline|σA| are subgroups of $A$.
%   \item<2> \lstinline[mathescape=true]|[GradedRing $\mathcal{A}$]| is an abbreviation for \lstinline[mathescape=true]|[DirectSum.Decomposition $\mathcal{A}$]| and 
% \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{A}$]| where \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{\McA}$]| is an abbreviation for 
% \lstinline[mathescape=true]|[SetLike.GradedOne $\mcA$]| asserting that $1$ has grade zero and \lstinline[mathescape=true]|[SetLike.GradedMul $\mcA$]| asserting that $\mcA_i\mcA_j \subseteq \mcA_{i+j}$.
  \item \lstinline[mathescape=true]|[SetLike.GradedSMul $\mcA$ $\mcM$]| asserts that $\mcA_i \cdot \mcM_j \subseteq \mcM_{i+j}$ where $i + j$ is provided by \lstinline|[VAdd ιA ιM]|. 
  % \item The general setup here is versatile: by allowing \lstinline|ιA| and \lstinline|ιM| to be different types, we can have graded rings and modules that are not graded by the same monoid --- for example the ring is graded by $\NN$ and the module by $\ZZ$.
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Graded objects in Lean4}

\begin{lstlisting}[mathescape=true, extendedchars=true]
variable {A M ιA ιM σA σM : Type*} 
variable [Ring A] [AddCommGroup M] [Module A M]
variable ($\mathcal{A}$ : ιA → σA) ($\mathcal{M}$ : ιM → σM)
variable [DecidableEq ιA] [AddMonoid ιA] [DecidableEq ιM]  [VAdd ιA ιM]
variable [SetLike σA A] [SetLike σM M]
variable [AddSubgroupClass σA A] [AddSubgroupClass σM M] 
variable [GradedRing $\mathcal{A}$] 
variable [DirectSum.Decomposition $\mathcal{M}$] [SetLike.GradedSMul $\mathcal{A}$ $\mathcal{M}$]
\end{lstlisting}
\begin{itemize}
%   \item<1> \lstinline|[SetLike σA A]| and \lstinline|[AddSubgroupClass σA A]| together assert that the terms of \lstinline|σA| are subgroups of $A$.
%   \item<2> \lstinline[mathescape=true]|[GradedRing $\mathcal{A}$]| is an abbreviation for \lstinline[mathescape=true]|[DirectSum.Decomposition $\mathcal{A}$]| and 
% \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{A}$]| where \lstinline[mathescape=true]|[SetLike.GradedMonoid $\mathcal{\McA}$]| is an abbreviation for 
% \lstinline[mathescape=true]|[SetLike.GradedOne $\mcA$]| asserting that $1$ has grade zero and \lstinline[mathescape=true]|[SetLike.GradedMul $\mcA$]| asserting that $\mcA_i\mcA_j \subseteq \mcA_{i+j}$.
  % \item \lstinline[mathescape=true]|[SetLike.GradedSMul $\mcA$ $\mcM$]| asserts that $\mcA_i \cdot \mcM_j \subseteq \mcM_{i+j}$ where $i + j$ is provided by \lstinline|[VAdd ιA ιM]|. 
  \item The general setup here is versatile: by allowing \lstinline|ιA| and \lstinline|ιM| to be different types, we can have graded rings and modules that are not graded by the same monoid --- for example the ring is graded by $\NN$ and the module by $\ZZ$.
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Graded Ring Homomorphisms}
\begin{lstlisting}[]
structure GradedRingHom extends RingHom A B where
  map_mem' : ∀ {i} {x : A}, 
    x ∈ 𝒜 i → toFun x ∈ ℬ i

scoped[Graded] infix:25 "→+*" => GradedRingHom
\end{lstlisting}

For a graded ring homomorphism $f : A \to B$, we define the corresponding ring homomorphism $\bigoplus_{i\in\iota}\mcA_i \to \bigoplus_{i\in\iota}\mcB_i$ by
\[
f_{\oplus} : \begin{tikzcd}[column sep=huge]
  \bigoplus_{i\in\iota} \mcA_i \arrow[r, "\decompose"] & A \arrow[r, "f"] & B \arrow[r, "\recompose"] & \bigoplus_{i\in\iota} \mcB_i.
\end{tikzcd}
\]
\begin{lstlisting}
def directSum (f : 𝒜 →+* ℬ) : (⨁ i, 𝒜 i) →+* (⨁ i, ℬ i) :=
  RingHom.comp (DirectSum.decomposeRingEquiv ℬ) <| 
    f.comp (DirectSum.decomposeRingEquiv 𝒜).symm
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Graded Ring Isomorphisms and Graded Algebra Homomorphisms etc.}
\begin{lstlisting}[extendedchars=true]
structure GradedRingEquiv extends RingEquiv A B where
  map_mem' : ∀ {i : ι} {x : A}, x ∈ 𝒜 i → toFun x ∈ ℬ i
  inv_mem' : ∀ {i : ι} {y : B}, y ∈ ℬ i → invFun y ∈ 𝒜 i

scoped[Graded] infix:25 "≃+*" => GradedRingEquiv

structure GradedAlgHom extends A →ₐ[R] B, GradedRingHom 𝒜 ℬ

scoped[Graded] notation:25 𝒜 " →ₐ[" R "] " ℬ => 
  GradedAlgHom (R := R) 𝒜 ℬ
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Localized Graded Rings}
  Let $S$ be a homogeneous submonoid of $A$. 
  Let $\mathcolorbox{yellow!10}{P_i}$ denote the set of qudraples $(a, b, d_a, d_b)$ where $d_a$ and $d_b$ are in $\iota$ such that $d_a - d_b = i$, 
$a \in A$ is homogeneous of degree $d_a$ and $b \in S$ is homogeneous of degree $d_b$.
For each $i \in \iota$, we give $P_i$ a group structure by: 
\begin{itemize}
  \item The zero element is $(0, 1, 0, 0)$.
  \item The result of adding $(a, b, d_a, d_b)$ and $(a', b', d_{a'}, d_{b'})$ is defined as
$(ab' + a'b, bb', d_a + d_{a'}, d_b + d_{b'})$.
  \item The negation of $(a, b, d_a, d_b)$ is defined as $(-a, b, d_a, d_b)$.
\end{itemize}
Hence, we have \sethlcolor{red!10}\hl{a group homomorphism $\mathsf{frac}: P_i \to A_{S}$ defined by $(a, b, d_a, d_{b}) \mapsto \frac{a}{b}$}.
Consider the quotient formed by $\quotient{P_{i}}{\sim}$ where \sethlcolor{green!10}\hl{two quadruples $p$ and $q$ are equivalent if and only if $\mathsf{frac}(p) = \mathsf{frac}(q)$}.
We take \sethlcolor{olive!10}\hl{the $i$-th grading $A_{S,i}$ of $A_S$ to be the range of the group homomorphism} \sethlcolor{purple!15}\hl{$\mathsf{frac} : \quotient{P_{i}}{\sim} \to A_{S}$}.

\end{frame}


\begin{frame}[fragile, allowframebreaks]
  \frametitle{Localized Graded Rings}
\begin{lstlisting}[linebackgroundcolor={%
  \ifnum\value{lstnumber}=10\color{red!10}\fi
  \ifnum\value{lstnumber}=11\color{red!10}\fi
  \ifnum\value{lstnumber}=12\color{red!10}\fi
  \ifnum\value{lstnumber}=13\color{red!10}\fi
  \ifnum\value{lstnumber}=14\color{red!10}\fi
  % \ifnum\value{lstnumber}=15\color{red!10}\fi
  \ifnum\value{lstnumber}=16\color{green!10}\fi
  \ifnum\value{lstnumber}=17\color{green!10}\fi
  % \ifnum\value{lstnumber}=19\color{green!10}\fi
  \ifnum\value{lstnumber}=19\color{purple!15}\fi
  \ifnum\value{lstnumber}=20\color{purple!15}\fi
  \ifnum\value{lstnumber}=21\color{purple!15}\fi
  % \ifnum\value{lstnumber}=24\color{purple!15}\fi
  \ifnum\value{lstnumber}=23\color{olive!10}\fi
  \ifnum\value{lstnumber}=24\color{olive!10}\fi
  \ifnum\value{lstnumber}=25\color{olive!10}\fi
}, caption={Grading of localized rings}]
structure (*@\sethlcolor{yellow!10}\hl{PreLocalizationGrading}@*) (i : ι) where
  num : A
  den : S.toSubmonoid
  degNum : ι
  degDen : ι
  num_mem : num ∈ 𝒜 degNum
  den_mem : (den : A) ∈ 𝒜 degDen
  deg_frac_eq : degNum - degDen = i

def val (i : ι) : 
    (S.PreLocalizationGrading i) →+ Localization S.toSubmonoid where
  toFun x := Localization.mk x.num x.den
  map_zero' := Localization.mk_zero 1
  map_add' := by simp [Localization.add_mk]

def addCon (i : ι) : AddCon (S.PreLocalizationGrading i) := 
  AddCon.ker (val S i)

def emb (i : ι) : 
    (addCon S i).Quotient →+ Localization S.toSubmonoid :=
  AddCon.lift _ (val ..) le_rfl

def LocalizationGrading (i : ι) : 
    AddSubgroup (Localization S.toSubmonoid) := 
  (PreLocalizationGrading.emb S i).range
\end{lstlisting} 
\end{frame}

\begin{frame}[fragile]
  \frametitle{Homogeneous Localization}
\begin{itemize}

  \item Let $R$ be a commutative ring and $A$ a commutative graded $R$-algebra. Let $x$ be a submonoid of $A$. 
  \item In general, unless $x$ contains only homogeneous elements, the localized ring $A_x$ is not graded.
  \item However, we can still investigate set $A_{(x)}$ of elements of degree zero in the localized ring. 
\end{itemize}

Consider the type $\mathcolorbox{yellow!10}{P}$ of triples of $(i, a, b)$ where $a$ and $b$ are 
  homogeneous elements of the degree $i$ and $b$ is in $x$, we have a function $\mathcolorbox{blue!10}{\mathsf{frac} : P \to A_{x}}$ defined by
  $(i, a, b) \mapsto =\frac a b$.
  We define the homogeneous localization $A_{(x)}$ to be the quotient $\quotient{P}{\sim}$ where \sethlcolor{red!10}\hl{two pairs $p$ and $q$
  are equivalent if and only if $\mathsf{frac}(p) = \mathsf{frac}(q)$}. 
  The function $\mathsf{frac}$ descends to an embedding $\mathcolorbox{green!10}{\iota: \hloca A{\mfp} \hookrightarrow A_{\mfp}}$.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Homogeneous Localization}
\begin{lstlisting}[linebackgroundcolor={%
  \ifnum\value{lstnumber}=1\color{yellow!10}\fi
  \ifnum\value{lstnumber}=2\color{yellow!10}\fi
  \ifnum\value{lstnumber}=3\color{yellow!10}\fi
  \ifnum\value{lstnumber}=4\color{yellow!10}\fi
  \ifnum\value{lstnumber}=6\color{blue!10}\fi
  \ifnum\value{lstnumber}=7\color{blue!10}\fi
  \ifnum\value{lstnumber}=8\color{blue!10}\fi
  \ifnum\value{lstnumber}=13\color{green!10}\fi
  \ifnum\value{lstnumber}=14\color{green!10}\fi
  \ifnum\value{lstnumber}=15\color{green!10}\fi},
  mathescape=true, caption={Homogeneous Localization}]
structure NumDenSameDeg where
  deg : ι
  (num den : 𝒜 deg)
  den_mem : (den : A) ∈ x

def embedding (p : NumDenSameDeg 𝒜 x) : 
    Localization x :=
  Localization.mk p.num ⟨p.den, p.den_mem⟩

def HomogeneousLocalization : Type _ :=
  Quotient <| (*@\sethlcolor{red!10}\hl{Setoid.ker <| embedding $\mcA$ x}@*)

def val (y : HomogeneousLocalization 𝒜 x) : 
    Localization x :=
  Quotient.liftOn' y (embedding 𝒜 x) ...
\end{lstlisting}

Why not just use a subring of $A_x$? 
\end{frame}


\begin{frame}[fragile]
  \frametitle{Graded Tensor Products}
\begin{itemize}
  \item 
  Let $A$ and $B$ be graded $R$-algebras where $A$ is graded by $\iota_{A}$ and $B$ is graded by $\iota_B$.
  \item 
  For any $i \in \iota_A$ and $j \in \iota_B$, the $(i,j)$-th graded piece of the tensor product $A \ox_R B$ is the 
  $A_i \ox_R B_j$. 
  \item 
  Since type theoretically, we need $A_i \ox_R B_j$ as a submodule of $A \ox_R B$, we use the range 
  of the linear map $A_i \ox_R B_j \to A \ox_R B$.
\end{itemize}
  \begin{lstlisting}[caption={Graded Tensor Product}]
noncomputable def gradingByProduct : 
    ιA × ιB → Submodule R (A ⊗[R] B) := fun p ↦ 
  LinearMap.range (TensorProduct.map (𝒜 p.1).subtype (ℬ p.2).subtype)

scoped infix:min "⊗" => gradingByProduct
  \end{lstlisting}
\end{frame}


\begin{frame}[fragile]
  \frametitle{Potions}
\begin{itemize}
  \item<1-> 
  Let $A$ be a commutative $R_0$-algebra that is graded by an abelian group $\iota$. 
  \item For any homogeneous submonoid $S \subseteq A$, we define the potion $\potion(S)$ to be the 
  homogeneous localization $\hloc A S$.
  \item<2-> If $\phi : A \to B$ is a graded ring homomorphism there is a ring homomorphism
  $\leanmath{potionToMap}: \potion(S) \to \potion\left(\phi_{\star} S\right)$ induced by $\phi$.
  \item<3-> If $S = T$ are two homogeneous submonoids of $A$, we have a ring isomorphism $\leanmath{potionEquiv}: \potion(S) \cong \potion(T)$.
  % In particular, since $S S = S$, we have a ring isomorphism $\potion(S)\cong \potion(SS)$.
  \item<4-> There is a ring homomorphism $\leanmath{potionToMul}:\potion(S) \to \potion(ST)$,
  with this ring homomorphism $\leanmath{potionToMul}$, we view $\potion(ST)$ as a $\potion(S)$-algebra.
  \item<5-> There is a ring isomorphism $\leanmath{equivBarPotion}: \potion(S) \cong \potion\left( \mybar{S} \right)$ induced by $\id_A$. This is \cref{eqn:isom-localizations} restricted to the zeroth degree.
\end{itemize}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Potion Generator}
  Suppose $S$ and $T$ be homogeneous submonoids of $A$. A \emph{potion generator} of $T$ over $S$ is the following data:
\begin{itemize}
  \item \sethlcolor{yellow!10}\hl{an indexing set $I$};
  \item \sethlcolor{red!10}\hl{a family of elements $\left\{ t_i \middle| i \in I \right\} \subseteq T$ generating $T$ as submonoid};
  \item \sethlcolor{blue!10}\hl{two families of elements $\left\{ s_i \middle| i \in I \right\} \subseteq \mybar{S}$ and  
  $\left\{ s_i' \middle| i \in I \right\} \subseteq \mybar{S}$ such that each $s_j$ is homogeneous of degree $i_j$ and 
  each $s_j'$ is homogeneous of degree $i'_j$};
  \item \sethlcolor{green!10}\hl{a family of positive natural numbers $\left\{ n_i\middle| i\in I \right\}$, such that for each $j \in I$,
  $t_j^{n_j}$ is homogeneous of degree $i_j - i'_j$}.
\end{itemize}
  
\begin{lstlisting}[extendedchars=true, caption={Potion Generator}, 
  linebackgroundcolor={%
  \ifnum\value{lstnumber}=2\color{yellow!10}\fi
  \ifnum\value{lstnumber}=3\color{red!10}\fi
  \ifnum\value{lstnumber}=4\color{red!10}\fi
  \ifnum\value{lstnumber}=5\color{red!10}\fi
  \ifnum\value{lstnumber}=6\color{blue!10}\fi
  \ifnum\value{lstnumber}=7\color{blue!10}\fi
  \ifnum\value{lstnumber}=8\color{blue!10}\fi
  \ifnum\value{lstnumber}=9\color{blue!10}\fi
  \ifnum\value{lstnumber}=10\color{blue!10}\fi
  \ifnum\value{lstnumber}=11\color{blue!10}\fi
  \ifnum\value{lstnumber}=12\color{green!10}\fi
  \ifnum\value{lstnumber}=13\color{green!10}\fi}, linebackgroundsep=-8pt, linebackgroundwidth=280pt,
  basicstyle=\ttfamily\footnotesize]
structure PotionGen where
  (index : Type*)
  (elem : index → A)
  (elem_mem : ∀ t, elem t ∈ T)
  (gen : Submonoid.closure (Set.range elem) = T.toSubmonoid)
  (s s' : index → A)
  (s_mem_bar : ∀ t, s t ∈ S.bar)
  (s'_mem_bar : ∀ t, s' t ∈ S.bar)
  (i i' : index → ι)
  (s_deg : ∀ t, s t ∈ 𝒜 (i t))
  (s'_deg : ∀ t, s' t ∈ 𝒜 (i' t))
  (n : index → ℕ+)
  (t_deg : ∀ t : index, (elem t : A)^(n t : ℕ) ∈ 𝒜 (i t - i' t))
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Potion Generator}
  For each $i$, the fraction $\frac{t_i^{n_i}s'_i}{s_i}$ is in $\potion\left( \mybar{S} \right)$.
We denote $\mathsf{s}(T')$ to the submonoid of $S$ generated by the $f_i$ where $f_i\in\potion(S)$ 
corresponds to the fraction $\frac{t_i^{n_i}s'_i}{s_i} \in \potion\left( \mybar{S} \right)$ under $\leanmath{equivBarPotion}$.
\begin{lstlisting}[extendedchars=true]
def PotionGen.genSubmonoid (T' : PotionGen S T) : Submonoid S.Potion :=
  Submonoid.closure
    { x | ∃ (t : T'.index), x =
      S.equivBarPotion.symm (.mk
        { deg := T'.i t,
          num := ⟨(T'.elem t) ^ (T'.n t : ℕ) * T'.s' t, ...⟩,
          den := ⟨T'.s t, T'.s_deg t⟩,
          den_mem := T'.s_mem_bar t }) }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Potion Generator}
  For any three $R, S, T$ homogeneous submonoids of $A$, 
  if $R' = \left( I_R, t_R, s_R, {s'}_R, i_R, {i'}_R, n_R \right)$ is a potion generator of $R$ over $S$ and 
  $T' = \left( I_T, t_T, s_T, {s'}_T, i_T, {i'}_T, n_T \right)$ is a potion generator of $T$ over $S$, 
  we have a potion generator of $RT$ over $S$ given by the disjoint union of the two potion generators:
  \[R' \oplus T' = (I_R \oplus I_T, s_R \oplus s_T, {s'}_R \oplus {s'}_T, i_R \oplus i_T, {i'}_R \oplus {i'}_T, n_R \oplus n_T).\]
It is useful to note that $\sfs\left( R'\oplus T' \right)$ is equal to $\sfs(R')\sfs(T')$.
\begin{lstlisting}[caption={Disjoint union of potion generators}, basicstyle=\ttfamily\footnotesize]
def PotionGen.disjUnion {R S T : HomogeneousSubmonoid 𝒜} (R' : PotionGen S R) (T' : PotionGen S T) :
    PotionGen S (R * T) where
  index := R'.index ⊕ T'.index
  elem := Sum.rec R'.elem T'.elem
  elem_mem := ...
  gen := ...
  n := Sum.rec R'.n T'.n
  s := Sum.rec R'.s T'.s
  s' := Sum.rec R'.s' T'.s'
  s_mem_bar := Sum.rec R'.s_mem_bar T'.s_mem_bar
  s'_mem_bar := Sum.rec R'.s'_mem_bar T'.s'_mem_bar
  i := Sum.rec R'.i T'.i
  i' := Sum.rec R'.i' T'.i'
  t_deg := Sum.rec R'.t_deg T'.t_deg
  s_deg := Sum.rec R'.s_deg T'.s_deg
  s'_deg := Sum.rec R'.s'_deg T'.s'_deg

lemma PotionGen.disjUnion_genSubmonoid {R S T : HomogeneousSubmonoid 𝒜}
      (R' : PotionGen S R) (T' : PotionGen S T) :
    (R'.disjUnion T').genSubmonoid = R'.genSubmonoid * T'.genSubmonoid := ...
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Magic of Potions}
\begin{theorem}
  Let $T' = \left( I, t, s, s', i, i', n \right)$ be a potion generator of $T$ over $S$.
  We have a $\potion(S)$-algebra isomorphism between $\potion( ST )$ and $\potion(S)_{\sfs(T')}$.
\end{theorem}

\begin{itemize}
  \item We descend the ring homomorphism $\leanmath{potionToMul} : \potion(S) \to \potion(ST)$ to a ring homomorphism $\potion(S)_{\sfs(T')} \to \potion(ST)$.
  \begin{lstlisting}
def localizationToPotion (T' : PotionGen S T) :
    Localization T'.genSubmonoid →+* (S * T).Potion :=
  @IsLocalization.lift
    (R := S.Potion)
    (M :=  _)
    (S :=  _)
    (P := (S * T).Potion)
    (g := S.potionToMul T) _ _ _ _
    (Localization.isLocalization (R := S.Potion) (M := T'.genSubmonoid)) 
    ...
  \end{lstlisting}
\end{itemize}

\end{frame}



\begin{frame}[fragile]
  \frametitle{Magic of Potions}
\begin{theorem}
  Let $T' = \left( I, t, s, s', i, i', n \right)$ be a potion generator of $T$ over $S$.
  We have a $\potion(S)$-algebra isomorphism between $\potion( ST )$ and $\potion(S)_{\sfs(T')}$.
\end{theorem}

\begin{itemize}
  \item Then, we check that it is both injective and surjective. Therefore, it is a $\potion(S)$-algebra isomorphism.
  \begin{lstlisting}[extendedchars=true]
def localizationRingEquivPotion (T' : PotionGen S T) :
    Localization T'.genSubmonoid ≃+* (S * T).Potion :=
  RingEquiv.ofBijective (localizationToPotion T') ...

def localizationAlgEquivPotion (T' : PotionGen S T) :
    Localization T'.genSubmonoid ≃ₐ[S.Potion] (S * T).Potion :=
  AlgEquiv.ofRingEquiv (f := localizationRingEquivPotion T') 
    fun x ↦ by
      induction x using Quotient.inductionOn' with | h x =>
      simp [localizationToPotion, Localization.mk_eq_mk', IsLocalization.lift_mk']
\end{lstlisting}
\end{itemize}

\end{frame}


\begin{frame}[fragile]
  \frametitle{Magic of Potions}
\begin{theorem}
  If $S$ is relevant and $T$ is finitely generated as a submonoid of $A$, there exists a finite potion generator $T'$ of $T$ over $S$. 
\end{theorem}
\begin{itemize}
  \item 
  This is because for every homogeneous element $t \in A$, there exists a positive natural number $n$,
  and two homogeneous elements $s, s' \in \mybar{S}$ of degree $i$ and $i'$ respectively such that $t^n \in A_{i - i'}$.
\begin{lstlisting}[]
lemma finite_potionGen_exists_aux₂ (S_rel : IsRelevant S) (t : A) (ht : SetLike.Homogeneous 𝒜 t) :
  ∃ (n : ℕ+) (s s' : A) (i i' : ι),
    t^(n : ℕ) ∈ 𝒜 (i - i') ∧ s ∈ 𝒜 i ∧ s' ∈ 𝒜 i' ∧ 
      s ∈ S.bar ∧ s' ∈ S.bar := ...
\end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Magic of Potions}
\begin{theorem}
  If $S$ is relevant and $T$ is finitely generated as a submonoid of $A$, there exists a finite potion generator $T'$ of $T$ over $S$. 
\end{theorem}
\begin{itemize}
  \item Then since $T$ is finitely generated, we can choose an arbitrary finite set $T' \subseteq T$ which generates $T$ as a submonoid.
  Hence, we can define functions 
  $n : T' \to \NN_{>0}$, $s, s' : T' \to A$, and $i, i' : T' \to \iota$ such that for each $t \in T'$,
  $s(t)$ and $s'(t)$ are homogeneous elements of degree $i(t)$ and $i'(t)$ respectively, and $t^{n(t)}$ is homogeneous of degree $i(t) - i'(t)$.
  These are exactly the data we need to define a finite potion generator of $T$ over $S$.
\end{itemize}
  \begin{lstlisting}[extendedchars=true, basicstyle=\ttfamily\footnotesize]
def finitePotionGen (S_rel : IsRelevant S) (T_fg : T.FG) : 
    PotionGen S T :=
  let carrier := T_fg.choose
  let gen : Submonoid.closure carrier = T.toSubmonoid := T_fg.choose_spec
  let n : carrier → ℕ+ := fun t ↦ (finite_potionGen_exists_aux₂ S_rel t ...).choose
  let s : carrier → A :=
    fun t ↦ (finite_potionGen_exists_aux₂ S_rel t ...).choose_spec.choose
  let s' : carrier → A := fun t ↦
    (finite_potionGen_exists_aux₂ S_rel t ...).choose_spec.choose_spec.choose
  let i : carrier → ι := fun t ↦
    (finite_potionGen_exists_aux₂ S_rel t ...).choose_spec.choose_spec.choose_spec.choose
  let i' : carrier → ι := fun t ↦
    (finite_potionGen_exists_aux₂ S_rel t ...).choose_spec.choose_spec.choose_spec.choose_spec.choose
  ...
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Magic of Potions}
\begin{corollary}
  If $S$ is relevant and $T$ is finitely generated as a submonoid of $A$, then $\spec \potion(ST) \to \spec \potion(S)$ is an open immersion.
\end{corollary}
  We have the following commutative triangle:
  \[
  \begin{tikzcd}[column sep=large]
    \potion(S) \arrow[r, "\leanmath{potionToMul}"] \arrow[d, "\frac{\bullet}{1}"] & \potion(ST) \arrow[ld, "\cong"] \\
    \potion(S)_{\sfs(T')} & \\
  \end{tikzcd}.
  \]
  Therefore, the morphism $\spec \potion(ST) \to \spec \potion(S)$ factorize as 
  \[\spec \potion(ST) \to \spec \potion(S)_{\sfs(T')} \cong \spec \potion(S).\]
\begin{lstlisting}
theorem IsOpenImmersion.of_isRelevant_FG 
    (S_rel : IsRelevant S) 
    (T_fg : T.FG) :
  IsOpenImmersion <| Spec.map <| CommRingCat.ofHom (S.potionToMul T) := ...
\end{lstlisting} 


\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}

Now, we restrict our attention to relevant and finitely generated homogeneous submonoids; we call such submonoids \emph{good potion ingredients}.
\begin{lstlisting}[caption={Good potion ingredients}]
structure GoodPotionIngredient extends (HomogeneousSubmonoid 𝒜) where
  relevant : toHomogeneousSubmonoid.IsRelevant
  fg : toSubmonoid.FG
\end{lstlisting}
For any three good potion ingredients $R, S, T$, we view $\potion(RST)$ as a $\potion(S)$-algebra via the ring homomorphism
$\potion(S) \to \potion(S(RT)) \to \potion(RST)$.
\end{frame}

\begin{frame}[fragile]
\frametitle{Mixing Potions}
  We have a $\potion(S)$-algebra isomorphism $e: \potion(ST) \ox_R \potion(SR) \cong \potion(RST)$ by 
  composing the following isomorphisms:
\begin{itemize}
  \item $\potion(ST) \ox_{\potion(S)} \potion(SR) \cong A_{\sfs(T')} \ox_{\potion(S)} A_{\sfs(R')}$
  \begin{lstlisting}
def mixingAux₀ :
    (S * T).Potion ⊗[S.Potion] (S * R).Potion ≃ₐ[S.Potion]
    (Localization T'.genSubmonoid) ⊗[S.Potion] 
    (Localization R'.genSubmonoid) :=
  Algebra.TensorProduct.congr
    (S.localizationAlgEquivPotion T').symm
    (S.localizationAlgEquivPotion R').symm
  \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mixing Potions}
  We have a $\potion(S)$-algebra isomorphism $e: \potion(ST) \ox_R \potion(SR) \cong \potion(RST)$ by 
  composing the following isomorphisms:
\begin{itemize}
  \item $A_{\sfs(T')} \ox_{\potion(S)} A_{\sfs(R')} \cong A_{\sfs(T')\sfs(R')}$
  \begin{lstlisting}
def mixingAux₁ {R S T : GoodPotionIngredient 𝒜}
    (R' : PotionGen S.1 R.1) (T' : PotionGen S.1 T.1) :
    (Localization T'.genSubmonoid) ⊗[S.Potion] 
    (Localization R'.genSubmonoid) ≃ₐ[S.Potion]
    Localization (T'.genSubmonoid * R'.genSubmonoid) :=
  Localization.mulEquivTensor _ _ |>.symm
  \end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}
  We have a $\potion(S)$-algebra isomorphism $e: \potion(ST) \ox_R \potion(SR) \cong \potion(RST)$ by 
  composing the following isomorphisms:
\begin{itemize}
  \item $A_{\sfs(T')\sfs(R')} \cong A_{\sfs(T'\oplus R')}$
  \begin{lstlisting}
def mixingAux₂ {R S T : GoodPotionIngredient 𝒜}
    (R' : PotionGen S.1 R.1) (T' : PotionGen S.1 T.1) :
    Localization (T'.genSubmonoid * R'.genSubmonoid) ≃ₐ[S.Potion]
    Localization (T'.disjUnion R').genSubmonoid :=
  Localization.equivEq 
    (PotionGen.disjUnion_genSubmonoid T' R').symm
  \end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}
  We have a $\potion(S)$-algebra isomorphism $e: \potion(ST) \ox_R \potion(SR) \cong \potion(RST)$ by 
  composing the following isomorphisms:
\begin{itemize}
  \item $A_{\sfs(T'\oplus R')} \cong \potion(S(TR))$
    \begin{lstlisting}
def mixingAux₃ {R S T : GoodPotionIngredient 𝒜}
    (R' : PotionGen S.1 R.1) (T' : PotionGen S.1 T.1) :
    Localization (T'.disjUnion R').genSubmonoid ≃ₐ[S.Potion]
    (S * (T * R)).Potion :=
  S.localizationAlgEquivPotion (T'.disjUnion R')
  \end{lstlisting}

  \item $\potion(S(TR)) \cong \potion(RST)$
  \begin{lstlisting}
def mixingAux₄ (R S T : GoodPotionIngredient 𝒜) :
    (S * (T * R)).Potion ≃ₐ[S.Potion] (R * S * T).Potion :=
  AlgEquiv.ofRingEquiv (f := potionEquiv ...) ...
  \end{lstlisting}

\item   \begin{lstlisting}[]
def mixing : 
    (S * T).Potion ⊗[S.Potion] (S * R).Potion ≃ₐ[S.Potion] (R * S * T).Potion :=
  mixingAux₀ R' T' |>.trans <| mixingAux₁ R' T' |>.trans <| mixingAux₂ R' T' |>.trans <|
  mixingAux₃ R' T' |>.trans <| mixingAux₄ R S T
  \end{lstlisting}
\end{itemize}
\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}
  We have a $\potion(S)$-algebra isomorphism $e: \potion(ST) \ox_R \potion(SR) \cong \potion(RST)$ by 
  composing the following isomorphisms:
\begin{itemize}
\item   \begin{lstlisting}[]
def mixing : 
    (S * T).Potion ⊗[S.Potion] (S * R).Potion ≃ₐ[S.Potion] (R * S * T).Potion :=
  mixingAux₀ R' T' |>.trans <| mixingAux₁ R' T' |>.trans <| mixingAux₂ R' T' |>.trans <|
  mixingAux₃ R' T' |>.trans <| mixingAux₄ R S T
  \end{lstlisting}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Mixing Potions}
With the same construction, we have an isomorphism 
$$\potion(RS) \ox_{\potion(R)} \potion(RT) \cong \potion(TRS) \cong \potion(RST).$$
Hence, we have an isomorphism
$$t'_{RST}: \potion(ST)\ox_{\potion(S)}\potion(SR) \cong \potion(RS) \ox_{\potion(R)} \potion(RT).$$

\begin{lstlisting}[extendedchars=true]
def t'Aux₀ (R S T : GoodPotionIngredient 𝒜) :
    (S * T).Potion ⊗[S.Potion] (S * R).Potion ≃+* (R * S * T).Potion :=
  mixing (finitePotionGen S.relevant R.fg) (finitePotionGen S.relevant T.fg)

def t'Aux₁ (R S T : GoodPotionIngredient 𝒜) :
    (R * S).Potion ⊗[R.Potion] (R * T).Potion ≃+* (R * S * T).Potion :=
  (mixing (finitePotionGen R.relevant T.fg) (finitePotionGen R.relevant S.fg)).toRingEquiv.trans <|
    potionEquiv (by rw [mul_comm T, mul_assoc, mul_comm T, ← mul_assoc])

def t' (R S T : GoodPotionIngredient 𝒜) :
    ((S * T).Potion ⊗[S.Potion] (S * R).Potion) ≃+*
    ((R * S).Potion ⊗[R.Potion] (R * T).Potion) :=
  (t'Aux₀ R S T).trans (t'Aux₁ R S T).symm
\end{lstlisting} 
\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}
\begin{corollary}
For any three good potion ingredients $R, S, T$, $t'_{TRS} \circ t'_{STR}\circ t'_{RST}$ is the identity isomorphism.
\end{corollary}

\begin{lstlisting}
lemma t'_cocycle (R S T : GoodPotionIngredient 𝒜) :
    (T.t' R S).trans ((S.t' T R).trans (R.t' S T))  = RingEquiv.refl _ := 
  ...
\end{lstlisting}

\end{frame}


\begin{frame}[fragile]
\frametitle{Mixing Potions}
\begin{corollary}{}{t-prime-fac-ring-version}
For any three good potion ingredients $R, S, T$, the following diagram commutes:
\[
\begin{tikzcd}
\potion(SR) \arrow[r, "1\ox\bullet"] \arrow[rd, "\cong", "\leanmath{potionEquiv}"'] & 
\potion(ST) \ox_{\potion(S)} \potion(SR) \arrow[r, "t'_{RST}"] & \potion(RS) \ox_{\potion(R)} \potion(RT) \\
& \potion(RS) \arrow[ru, "1\ox\bullet"]& 
\end{tikzcd}.
\]
\end{corollary}


\begin{lstlisting}
lemma t'_fac (R S T : GoodPotionIngredient 𝒜) :
    ((R.t' S T)).toRingHom.comp Algebra.TensorProduct.includeRight.toRingHom =
    Algebra.TensorProduct.includeLeftRingHom.comp
      (potionEquiv <| by rw [mul_comm]).toRingHom := 
  ...
\end{lstlisting}
\end{frame}

\begin{frame}
\begin{center}
Thanks for listening
\end{center}
\end{frame}

\end{document} 